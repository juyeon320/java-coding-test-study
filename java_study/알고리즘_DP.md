# DP , 동적프로그래밍

## 복잡한 문제를 작은 하위 문제로 나누어 풀고, 하위 문제의 결과를 재활용하여 전체 문제를 해결하는 알고리즘 기법

### "한번 계산한 결과는 다시 계산하지 않고 다시 저장해서 사용"
### 📁 적용 조건 (DP 사용 가능한 문제의 조건)
- Overlapping Subproblems (중복되는 부분 문제)
→ 동일한 하위 문제를 여러 번 계산하는 경우.

- Optimal Substructure (최적 부분 구조)
→ 전체 문제의 최적해가 부분 문제의 최적해로 구성되는 경우.


### 🔧 구현 방식
1. Top-Down (재귀 + 메모이제이션)
   재귀 호출을 사용하되, 이미 계산한 값은 배열에 저장하여 반복 계산을 피함.

```
int fib(int n) {
if (n <= 1) return n;
if (dp[n] != -1) return dp[n];
return dp[n] = fib(n - 1) + fib(n - 2);
}
```

2. Bottom-Up (반복문 + 테이블 채우기)
   작은 문제부터 차례로 값을 구해가며 최종 해를 도출.

```
dp[0] = 0;
dp[1] = 1;
for (int i = 2; i <= n; i++) {
dp[i] = dp[i - 1] + dp[i - 2];
}
```